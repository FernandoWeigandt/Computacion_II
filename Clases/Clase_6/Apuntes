1. Conceptos Fundamentales de FIFOs üß†
‚Ä¢ Los FIFOs (First In, First Out) o pipes con nombre son mecanismos de comunicaci√≥n entre procesos que se representan como archivos especiales en el sistema de archivos.
‚Ä¢ A diferencia de los pipes an√≥nimos, los FIFOs permiten la comunicaci√≥n entre procesos no relacionados, ya que persisten como archivos accesibles por m√∫ltiples procesos.
‚Ä¢ Son √∫tiles para sistemas donde los procesos no se crean entre s√≠, como servicios independientes o daemons.

2. Ciclo de Vida de un FIFO üîÑ
‚Ä¢ Creaci√≥n: Se usa os.mkfifo() o el comando mkfifo en terminal.
‚Ä¢ Conexi√≥n: Un proceso lo abre para lectura y otro para escritura. Si uno intenta abrir en modo bloqueante y no hay nadie del otro lado, se queda esperando.
‚Ä¢ Comunicaci√≥n: Se usa open(), read(), write() en el archivo FIFO como si fuera un archivo com√∫n, pero sin almacenamiento persistente.
‚Ä¢ Eliminaci√≥n: Se puede borrar con os.remove() o rm, pero los procesos que ya lo tienen abierto pueden seguir us√°ndolo mientras dure la sesi√≥n.

3. Implementaci√≥n en Python üíª
‚Ä¢ Los procesos usan os.open() y os.read() / os.write() para interactuar con el FIFO.
‚Ä¢ Se pueden usar procesos independientes o scripts diferentes, ya que el FIFO act√∫a como punto de encuentro.
‚Ä¢ La escritura y lectura son bloqueantes por defecto, pero se puede usar O_NONBLOCK para comportamiento no bloqueante.

4. Bloqueos y Consideraciones üö´
‚Ä¢ Bloqueo del escritor: Si no hay lector, open(fifo, 'w') se bloquea.
‚Ä¢ Bloqueo del lector: Si no hay escritor, open(fifo, 'r') tambi√©n se bloquea hasta que alguien escriba.
‚Ä¢ Evitar bloqueos: Siempre iniciar el lector antes que el escritor o usar modo no bloqueante con manejo de errores (ENXIO).

5. Ejemplos Pr√°cticos üß™
‚Ä¢ Se implement√≥ un logger por FIFO, donde un proceso escribe logs y otro los muestra.
‚Ä¢ Analizamos comportamiento bloqueante, atomicidad de escritura (segura si ‚â§ PIPE_BUF), y qu√© pasa si m√∫ltiples lectores o escritores interact√∫an al mismo tiempo.
‚Ä¢ Se identificaron las limitaciones de los FIFOs para sistemas de broadcast (un mensaje le√≠do desaparece del flujo).

6. Patrones de Comunicaci√≥n Avanzados üîÑ
‚Ä¢ Multilectores: No es viable con un solo FIFO si todos deben recibir los mismos datos.
‚Ä¢ Se sugirieron alternativas como:
- Un FIFO por lector.
- Un proceso central que reenv√≠e mensajes a m√∫ltiples destinos.
- Uso de sockets, message queues, o protocolos pub-sub como MQTT.
‚Ä¢ Tambi√©n se discuti√≥ c√≥mo gestionar m√∫ltiples niveles de log y mejorar la arquitectura de servicios concurrentes usando estos conceptos.
